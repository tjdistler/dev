// Models the fermenter and beer
"use strict";

var GRAMS_PER_LITER = 998.2;
var CALORIES_PER_WATT = 0.239;

function wattsToCalories(W) {
    return W * CALORIES_PER_WATT;
}

function caloriesToWatts(c) {
    return c / CALORIES_PER_WATT;
}



var Fermenter = function (beerVolumeL, beerStartTempC, fermentationHeatW, thermalConductivityWmC, surfaceAreaM2, surfaceThicknessM, surfaceExposedP, stepTimeS) {
    this._beerVolumeG = beerVolumeL * GRAMS_PER_LITER;
    this._beerStartTempC = beerStartTempC;
    this._fermentationHeatW = fermentationHeatW;
    this._thermalConductivityWmC = thermalConductivityWmC;
    this._surfaceAreaM2 = surfaceAreaM2 * surfaceExposedP;
    this._surfaceThicknessM = surfaceThicknessM;
    this._stepTimeS = stepTimeS;
    
    this._currentStep = 0;
    this._currentTemp = beerStartTempC;
}


Fermenter.prototype.getTemperature = function() {
    return this._currentTemp;
}


Fermenter.prototype.updateState = function(externalTempC) {
    
    // Add heat generated by fermentation.
    this.addEnergy(this._fermentationHeatW * this._stepTimeS);
    
    // Remove heat lost to external environment
    // Q = kA(T1 - T2) / d
    var rateW = ( this._thermalConductivityWmC * this._surfaceAreaM2 * (externalTempC - this._currentTemp) ) / this._surfaceThicknessM;
    this.addEnergy( rateW * this._stepTimeS );
}


// This method does NOT have a time component. It assumes any time scaling has occurred.
Fermenter.prototype.addEnergy = function(energyW) {
    
    // T(C) = c/m(grams)
    var calories = wattsToCalories(energyW);
    this._currentTemp += calories / this._beerVolumeG;
}